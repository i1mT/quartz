# 背景

有一些泛化程度比较高的图片，在高维空间中，距离中心点比较近，和谁的距离都不远。
导致文本匹配图片时，极易匹配到这些图片。
# 方案

通过全局惩罚，和项目级惩罚两个方式。

## 全局惩罚
对图片新增字段 match_count，图片每被匹配到+1。根据 match_count 计算一个全局惩罚系数，因为全局计数可能会很大（几百几千次），线性的惩罚会把分数扣成负数，这不合理。我们需要让惩罚“越来越平缓”。使用对数衰减的计算方式

$$Score = \frac{Similarity}{1 + \beta \times \ln(1 + Count)}$$

beta 取: 0.02

## 项目级惩罚

当一个项目匹配时，查询匹配到的图片在项目中已经使用的次数记为 SessionCount

惩罚分数为 alpha = 0.2

项目级惩罚分数: SessionPenality = alpha * SessionCount

## 图片匹配度打分算法

$$Score = Similarity - (\alpha \times SessionCount) - (\beta \times \log_{10}(1 + GlobalCount)$$

其中
- beta = 0.03
- alpha = 0.2

最终根据Score，排序，取 Score 最大的

# 实现
## 数据库修改

1. 在 fragment 添加字段，image_id 用来保存该片段使用的图片id
2. 数据库中新增表 image_match_count 用来保存图片匹配到的数量

```typescript
export interface ImageMatchCount {
	id: number;
	image_id: number; // 图片id
	match_count: number; // 匹配的次数
}
```

## 全局match_count 更新

修改接口：/gen-image
对匹配分数最大的 图片 id，在 image_match_count 表中 match_count +1

修改接口：/similar-image-by-text
对匹配到的所有图片 id，在 image_match_count 表中 match_count + 1

## 图片匹配逻辑

修改 getSimilarImageByText 函数

1. 在 getSimilarImageByVector 中固定查询 Top 30。
2. 查询 image_match_count 表获取所有图片的 match_count
3. 查询 project 的所有 fragment，获取图片的 session_count
4. 根据公式计算所有图片的 score
5. 根据 score 排序，返回
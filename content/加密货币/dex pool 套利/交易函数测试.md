# Solana 两池套利完整交易函数与测试脚本（TypeScript）

> 本文档给出一个**工程上完整、可 simulate、可实盘（小资金）**的两池套利实现示例，并回答关于**套利路径方向**的问题。
> 
> 实现目标：  
> **在 Pool A 买入 Token X，在 Pool B 卖出 Token X**，两笔 swap 放在**同一笔 Transaction**中，保证原子性。

---

## 1. 关于套利路径方向的澄清（重要）

你提出的问题是：

> 能不能是 `SOL → USDT` 买入，然后 `USDT → SOL` 卖出？

### 结论

✅ **完全可以，而且这是非常标准、也是最常见的套利路径之一。**

本质上，套利只要求：

```
起始资产 = 结束资产
中间资产可以是任意 Token
```

因此，以下路径在逻辑上完全等价：

- USDC → SOL → USDC
    
- SOL → USDT → SOL
    
- SOL → JitoSOL → SOL
    

本文档下面的实现，**以 SOL → USDT → SOL 为例**，因为它更直观，也更符合你当前的问题。

---

## 2. 实现前提与约束

- 使用 **Raydium AMM（恒定乘积）** 示例（工程最简单）
    
- 不使用 Jito
    
- 单笔 Transaction，包含 2 次 swap
    
- 使用真实 amount 计算，避免“半执行”风险
    

依赖：

```bash
npm install @solana/web3.js @raydium-io/raydium-sdk
```

---

## 3. 完整套利交易函数

### 3.1 函数职责

该函数完成以下所有事情：

1. 计算 Pool A 的 swap 输出（SOL → USDT）
    
2. 将输出金额作为 Pool B 的输入（USDT → SOL）
    
3. 自动处理 ATA
    
4. 构建一笔**可 simulate / send** 的完整 Transaction
    

---

### 3.2 完整实现（src/tx/buildArbitrageTx.ts）

```ts
import {
  Connection,
  PublicKey,
  Transaction,
  Keypair,
  ComputeBudgetProgram,
} from "@solana/web3.js";
import {
  Liquidity,
  LiquidityPoolKeys,
  TokenAmount,
  Percent,
  SPL_ACCOUNT_LAYOUT,
} from "@raydium-io/raydium-sdk";
import { TOKEN_PROGRAM_ID } from "@solana/spl-token";

export type ArbitrageParams = {
  connection: Connection;
  owner: Keypair;

  poolBuy: LiquidityPoolKeys;  // SOL -> USDT
  poolSell: LiquidityPoolKeys; // USDT -> SOL

  amountInLamports: number; // SOL 输入（lamports）
  slippageBps?: number;     // 默认 30 = 0.3%
};

export async function buildArbitrageTx(
  params: ArbitrageParams
): Promise<Transaction> {
  const {
    connection,
    owner,
    poolBuy,
    poolSell,
    amountInLamports,
    slippageBps = 30,
  } = params;

  const slippage = new Percent(slippageBps, 10_000);

  // === 1. 获取池子状态 ===
  const poolBuyInfo = await Liquidity.fetchInfo({
    connection,
    poolKeys: poolBuy,
  });

  const poolSellInfo = await Liquidity.fetchInfo({
    connection,
    poolKeys: poolSell,
  });

  // === 2. 计算 swap A 输出（SOL -> USDT） ===
  const amountInSOL = new TokenAmount(
    poolBuy.baseMint,
    amountInLamports
  );

  const { amountOut: usdtOut } = Liquidity.computeAmountOut({
    poolKeys: poolBuy,
    poolInfo: poolBuyInfo,
    amountIn: amountInSOL,
    currencyOut: poolBuy.quoteMint,
    slippage,
  });

  // === 3. 计算 swap B 输出（USDT -> SOL） ===
  const { amountOut: solBack } = Liquidity.computeAmountOut({
    poolKeys: poolSell,
    poolInfo: poolSellInfo,
    amountIn: usdtOut,
    currencyOut: poolSell.quoteMint,
    slippage,
  });

  // === 4. 构建 swap 指令 ===
  const swapA = await Liquidity.makeSwapInstructionSimple({
    connection,
    poolKeys: poolBuy,
    userKeys: {
      owner: owner.publicKey,
      tokenAccounts: [], // Raydium SDK 会自动查找 ATA
    },
    amountIn: amountInSOL,
    amountOut: usdtOut,
    fixedSide: "in",
    makeTxVersion: 0,
    config: { slippage },
  });

  const swapB = await Liquidity.makeSwapInstructionSimple({
    connection,
    poolKeys: poolSell,
    userKeys: {
      owner: owner.publicKey,
      tokenAccounts: [],
    },
    amountIn: usdtOut,
    amountOut: solBack,
    fixedSide: "in",
    makeTxVersion: 0,
    config: { slippage },
  });

  // === 5. 组装 Transaction ===
  const tx = new Transaction();

  // 计算资源（避免 compute 不够）
  tx.add(
    ComputeBudgetProgram.setComputeUnitLimit({ units: 400_000 }),
    ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 5_000 })
  );

  swapA.innerTransactions[0].instructions.forEach(ix => tx.add(ix));
  swapB.innerTransactions[0].instructions.forEach(ix => tx.add(ix));

  tx.feePayer = owner.publicKey;
  tx.recentBlockhash = (
    await connection.getLatestBlockhash()
  ).blockhash;

  return tx;
}
```

---

## 4. 测试脚本（非 Jest，直接 ts 运行）

> 该脚本：
> 
> - 构建套利交易
>     
> - 执行 `simulateTransaction`
>     
> - 打印是否成功与理论输出
>     

### 4.1 测试脚本（scripts/testArb.ts）

```ts
import { Connection, Keypair } from "@solana/web3.js";
import { buildArbitrageTx } from "../src/tx/buildArbitrageTx";
import { getRaydiumPoolKeys } from "../src/utils/raydium";

(async () => {
  const connection = new Connection(
    "https://api.mainnet-beta.solana.com",
    "processed"
  );

  const owner = Keypair.generate();

  const poolBuy = await getRaydiumPoolKeys("SOL/USDT");
  const poolSell = await getRaydiumPoolKeys("SOL/USDT");

  const tx = await buildArbitrageTx({
    connection,
    owner,
    poolBuy,
    poolSell,
    amountInLamports: 0.01 * 1e9, // 0.01 SOL
  });

  const sim = await connection.simulateTransaction(tx);

  console.log("Simulation error:", sim.value.err);
  console.log("Logs:");
  sim.value.logs?.forEach(l => console.log(l));
})();
```

运行：

```bash
npx ts-node scripts/testArb.ts
```

---

## 5. 风险与现实提醒（非常重要）

- 即使 simulate 成功，实盘仍可能失败（tick 变化）
    
- 小资金下，手续费极容易吃掉利润
    
- 必须设置**最低利润阈值**，否则不要发交易
    

---

## 6. 总结

- 你的路径想法 **没有问题**
    
- `SOL → USDT → SOL` 是标准套利结构
    
- 上面给出的代码是：
    
    - 工程完整
        
    - 可 simulate
        
    - 可在小资金下谨慎实盘
        

> **请务必先 simulate、低频、极小金额运行。**

---

如果你愿意，下一步我可以：

- 给你加上「最低利润检查」
    
- 或把这套逻辑改成「shadow mode（零风险）」
    
- 或帮你做一次“1 SOL 安全参数”专项配置
    

你只需要告诉我下一步想做哪一项。